package com.tpos.soss.util.file;

import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.apache.commons.io.FilenameUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import com.tpos.soss.admin.fileconfig.FileConfigService;
import com.tpos.soss.admin.fileconfig.FileConfigVO;

@Service
public class FileCheck {
	private static final Logger logger = LoggerFactory.getLogger(FileCheck.class);
	
	@Autowired
	private FileConfigService fileConfigService;
	
	@Value("#{string['xls.mime_type']}")
	private String xls_mime_type;
	
	@Value("#{string['xls.hex_header']}")
	private String xls_hex_header;
	
	@Value("#{string['xlsx.mime_type']}")
	private String xlsx_mime_type;
	
	@Value("#{string['xlsx.hex_header']}")
	private String xlsx_hex_header;
	
	@Value("#{string['file.block.extension']}")
	private String block_extension;
	
	// 엑셀 파일 체크
	public boolean excelFileCheck(MultipartFile file) throws Exception {
		logger.info("[엑셀 파일 업로드 체크] " + file.getOriginalFilename());	
		
		boolean result = true;
		
		//xls
		List<int[]> xlsSignatureList = new ArrayList<int[]>();
		xlsSignatureList.add(new int[] { 0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1 });
				
		if(StringUtils.isNoneEmpty(xls_hex_header)) {
			try {
				String hexString = null;
				String[] hexSplit = null;
				for(int i=0; i<xls_hex_header.split(",").length; i++) {
					hexString = xls_hex_header.split(",")[i].trim();
					hexSplit = hexString.split(" ");
					
					int [] hex = new int[hexSplit.length];
					
					for(int n=0; n<hexSplit.length;n++) {
						hex[n] = Integer.parseInt(hexSplit[n], 16);
					}
					
					xlsSignatureList.add(hex);
				}
			}
			catch(Exception e) {
				e.printStackTrace();
			}
		}

		//xlsx
		List<int[]> xlsxSignatureList = new ArrayList<int[]>();
		xlsxSignatureList.add(new int[] { 0x50, 0x4B, 0x03, 0x04, 0x14, 0x00, 0x06, 0x00 });
		xlsxSignatureList.add(new int[] { 0x50, 0x4B, 0x03, 0x04, 0x14, 0x00, 0x08 });

		if(StringUtils.isNoneEmpty(xlsx_hex_header)) {
			try {
				String hexString = null;
				String[] hexSplit = null;
				for(int i=0; i<xlsx_hex_header.split(",").length; i++) {
					hexString = xlsx_hex_header.split(",")[i].trim();
					hexSplit = hexString.split(" ");
					
					int [] hex = new int[hexSplit.length];
					
					for(int n=0; n<hexSplit.length;n++) {
						hex[n] = Integer.parseInt(hexSplit[n], 16);
					}
					
					xlsxSignatureList.add(hex);
				}
			}
			catch(Exception e) {
				e.printStackTrace();
			}
		}
		
		List<int[]> hexSignatureList = new ArrayList<int[]>();
		
		String xlsxMimeType = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
		if(StringUtils.isNoneEmpty(xlsx_mime_type)) {
			xlsxMimeType = xlsx_mime_type.trim();
		}
		
		String xlsMimeType = "application/vnd.ms-excel";
		if(StringUtils.isNoneEmpty(xls_mime_type)) {
			xlsMimeType = xls_mime_type.trim();
		}
		
		// 확장자
		String extension = FilenameUtils.getExtension(file.getOriginalFilename());
		
		// 파일 크기 (최대 50M)
		long maxSize = 50*1024*1024;
		
		// 파일 크기 및 확장자 체크
		if(file.getSize() <= maxSize && (extension.equals("xls") || extension.equals("xlsx"))) {
			// MIME 체크
			Path source = Paths.get(file.getOriginalFilename());
			String mimeType = Files.probeContentType(source);
			
			if(xlsxMimeType.equals(mimeType) || xlsMimeType.equals(mimeType) || mimeType == null || mimeType.equals(null)) {
				if(extension.equals("xls") && xlsMimeType.equals(mimeType)) {
					hexSignatureList = xlsSignatureList;
				}
				else if(extension.equals("xlsx") && xlsxMimeType.equals(mimeType)) {
					hexSignatureList = xlsxSignatureList;
				}
				
				// 헤더 시그니처 체크
				int[] hexSignature = null;
				
				for(int i=0; i<hexSignatureList.size(); i++) {
					InputStream is = file.getInputStream();
					hexSignature = hexSignatureList.get(i);
				
					result = true;
					for(int h=0; h<hexSignature.length; h++) {					
						
						// 하나의 헤더 정보가 모두 같은지 체크
						if(is.read() != hexSignature[h]) {
							result = false;
							break;
						}
					}
					
					// 모두 같은게 존재
					if(result) {
						break;
					}
				}
			}
			else {
				// MIME Type 실패
				result = false;
				logger.error("[엑셀 업로드 실패][MIME Type] " + mimeType);
			}
		}
		else {
			// 파일 크기 및 확장자 실패
			result = false;
			logger.error("[엑셀 업로드 실패][파일 크기 및 확장자 필터] " + extension + ":" + file.getSize());
		}
		
		return result;
	}
	
	// 파일 체크 부분
	public boolean tableTypeFileCheck(String type, MultipartFile file) throws Exception {
		boolean result = true;
		
		try {
			String[] headerSplit = null;
			Path source = Paths.get(file.getOriginalFilename());
			String mimeType = Files.probeContentType(source);
			String extension = FilenameUtils.getExtension(file.getOriginalFilename());
			
			// 파일 체크 부분
			// 차단 확장자 체크
			String blockString = block_extension.replaceAll("[\t| ]", "");
			blockString = blockString.replaceAll(",", "\n").toLowerCase();
			String [] blockSplit = blockString.split("\n");
			
			if(StringUtils.isNoneEmpty(extension) && Arrays.asList(blockSplit).contains(extension.toLowerCase())) {
				result = false;
				logger.error("[업로드 실패][차단 확장자] " + extension);
			}
			
			// 2. DB
			if(result) {
				result = false;
				
				FileConfigVO vo = new FileConfigVO();
				vo.setTablename(type);
				vo.setExtension(extension);
				List<FileConfigVO> fileConfigList = fileConfigService.selectTablenameExtension(vo);
				
				if(fileConfigList.size() > 0) {
					for(int i=0; i<fileConfigList.size(); i++) {
						result = false;
						vo = fileConfigList.get(i);
						
						// 크기 체크
						if(file.getSize() <= vo.getMaxsize()) {
							result = true;
							
							// 헤더 체크
							if(StringUtils.isNoneEmpty(vo.getHeader())) {					
								// 파일 스트림
								InputStream is = file.getInputStream();					
								headerSplit = vo.getHeader().trim().split(" ");
								
								// 헤더 시그니처 체크
								for(int h=0; h<headerSplit.length; h++) {
									// 하나의 헤더 정보가 모두 같은지 체크
									if(is.read() != Integer.parseInt(headerSplit[h], 16)) {
										result = false;
										break;
									}
								}
							}
							
							if(result) {
								// MIME Type 체크
								if(StringUtils.isNoneEmpty(vo.getMimetype())) {
									result = false;
									
									if(mimeType != null && mimeType.equals(vo.getMimetype())) {
										result = true;
									}
									else {
										logger.error("[업로드 실패][MIME Type] " + mimeType);
									}
								}
							}
							else {
								logger.error("[업로드 실패][파일 헤더 다름]");
							}
						}
						else {
							logger.error("[업로드 실패][파일 크기] " + file.getSize());
						}
						
						// 같은게 존재
						if(result) {
							break;
						}
					}
				}
				else {
					logger.error("[업로드 실패][등록 된 파일 정보 없음] " + file.getOriginalFilename());
				}
			}
		}
		catch(Exception e) {
			result = false;
			
			e.printStackTrace();
		}
		
		return result;
	}
	
	
	
	
	
	
//	private static Map<String, List<int[]>> fileHeaderInfo = new HashMap<String, List<int[]>>();
//	static {
//		List<int[]> hexSignatureList = new ArrayList<int[]>();
//		String extension = null;
//		
//		// 오피스 종류
//		extension = "ppt";
//		hexSignatureList = new ArrayList<int[]>();
//		hexSignatureList.add(new int[] { 0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1 });
//		hexSignatureList.add(new int[] { 0x00, 0x6E, 0x1E, 0xF0 });
//		hexSignatureList.add(new int[] { 0x0F, 0x00, 0xE8, 0x03 });
//		hexSignatureList.add(new int[] { 0xA0, 0x46, 0x1D, 0xF0 });
//		hexSignatureList.add(new int[] { 0xFD, 0xFF, 0xFF, 0xFF, 0x0E, 0x00, 0x00, 0x00 });
//		hexSignatureList.add(new int[] { 0xFD, 0xFF, 0xFF, 0xFF, 0x1C, 0x00, 0x00, 0x00 });
//		hexSignatureList.add(new int[] { 0xFD, 0xFF, 0xFF, 0xFF, 0x43, 0x00, 0x00, 0x00 });
//		fileHeaderInfo.put(extension, hexSignatureList);
//		
//		extension = "doc";
//		hexSignatureList = new ArrayList<int[]>();
//		hexSignatureList.add(new int[] { 0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1 });
//		hexSignatureList.add(new int[] { 0x0D, 0x44, 0x4F, 0x43 });
//		hexSignatureList.add(new int[] { 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1, 0x00 });
//		hexSignatureList.add(new int[] { 0xDB, 0xA5, 0x2D, 0x00 });
//		hexSignatureList.add(new int[] { 0xEC, 0xA5, 0xC1, 0x00 });
//		fileHeaderInfo.put(extension, hexSignatureList);
//		
//		extension = "xls";
//		hexSignatureList = new ArrayList<int[]>();
//		hexSignatureList.add(new int[] { 0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1 });
//		hexSignatureList.add(new int[] { 0x09, 0x08, 0x10, 0x00, 0x00, 0x06, 0x05, 0x00 });
//		hexSignatureList.add(new int[] { 0xFD, 0xFF, 0xFF, 0xFF, 0x10 });
//		hexSignatureList.add(new int[] { 0xFD, 0xFF, 0xFF, 0xFF, 0x1F });
//		hexSignatureList.add(new int[] { 0xFD, 0xFF, 0xFF, 0xFF, 0x22 });
//		hexSignatureList.add(new int[] { 0xFD, 0xFF, 0xFF, 0xFF, 0x23 });
//		hexSignatureList.add(new int[] { 0xFD, 0xFF, 0xFF, 0xFF, 0x28 });
//		hexSignatureList.add(new int[] { 0xFD, 0xFF, 0xFF, 0xFF, 0x29 });
//		fileHeaderInfo.put(extension, hexSignatureList);
//		
//		extension = "pptx";
//		hexSignatureList = new ArrayList<int[]>();
//		hexSignatureList.add(new int[] { 0x50, 0x4B, 0x03, 0x04 });
//		hexSignatureList.add(new int[] { 0x50, 0x4B, 0x03, 0x04, 0x14, 0x00, 0x06, 0x00 });
//		fileHeaderInfo.put(extension, hexSignatureList);
//		
//		extension = "docx";
//		hexSignatureList = new ArrayList<int[]>();
//		hexSignatureList.add(new int[] { 0x50, 0x4B, 0x03, 0x04 });
//		hexSignatureList.add(new int[] { 0x50, 0x4B, 0x03, 0x04, 0x14, 0x00, 0x06, 0x00 });
//		fileHeaderInfo.put(extension, hexSignatureList);
//
//		extension = "xlsx";
//		hexSignatureList = new ArrayList<int[]>();
//		hexSignatureList.add(new int[] { 0x50, 0x4B, 0x03, 0x04 });
//		hexSignatureList.add(new int[] { 0x50, 0x4B, 0x03, 0x04, 0x14, 0x00, 0x06, 0x00 });
//		fileHeaderInfo.put(extension, hexSignatureList);
//	
//		// 압축 종류
//	}
//	
//	public static boolean fileHeaderCheck(File file) throws Exception {
//		boolean result = true;
//		
//		// 파일
//		FileInputStream ins = new FileInputStream(file);
//		
//		// 확장자
//		String extension = FilenameUtils.getExtension(file.getAbsolutePath());
//		System.out.println("[확장자] "+extension);
//		
//		// 확장자별 헤더 정보 리스트 (여러 헤더일 수 있음)
//		List<int[]> hexSignatureList = fileHeaderInfo.get(extension);
//		int[] hexSignature = null;
//		
//		for(int i=0; i<hexSignatureList.size(); i++) {
//			hexSignature = hexSignatureList.get(i);
//			
//			result = true;
//			for(int h=0; h<hexSignature.length; h++) {
//				// 하나의 헤더 정보가 모두 같은지 체크
//				if(ins.read() != hexSignature[h]) {
//					result = false;
//					break;
//				}
//			}
//			
//			// 모두 같은게 존재
//			if(result) {
//				break;
//			}
//		}
//		
//		ins.close();
//		
//		return result;
//	}
//	
//	public static boolean fileHeaderCheck(MultipartFile file) throws Exception {
//		boolean result = true;
//		
//		// 파일
//		InputStream ins = file.getInputStream();
//		
//		// 확장자
//		String extension = FilenameUtils.getExtension(file.getOriginalFilename());
//		System.out.println("[확장자] "+extension);
//		
//		// MIME 체크
//		Path source = Paths.get(file.getOriginalFilename());
//		String mimeType = Files.probeContentType(source);
//		System.out.println("[MIME Type] "+mimeType);
//		
//		// 확장자별 헤더 정보 리스트 (여러 헤더일 수 있음)
//		List<int[]> hexSignatureList = fileHeaderInfo.get(extension);
//		int[] hexSignature = null;
//		
//		for(int i=0; i<hexSignatureList.size(); i++) {
//			hexSignature = hexSignatureList.get(i);			
//			System.out.println(Arrays.toString(hexSignature));
//			
//			result = true;
//			for(int h=0; h<hexSignature.length; h++) {
//				// 하나의 헤더 정보가 모두 같은지 체크
//				if(ins.read() != hexSignature[h]) {
//					result = false;
//					break;
//				}
//			}
//			
//			// 모두 같은게 존재
//			if(result) {
//				break;
//			}
//		}
//		
//		ins.close();
//		
//		return result;
//	}

// 티카 사용법
// https://offbyone.tistory.com/330

// 헤더 정보
// https://www.garykessler.net/library/file_sigs.html
// http://forensic-proof.com/archives/300
// https://filesignatures.net/index.php?page=search
// https://pythonq.com/so/java/1648337
}
